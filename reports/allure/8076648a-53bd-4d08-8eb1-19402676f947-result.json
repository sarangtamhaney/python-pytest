{"name": "test_google", "status": "broken", "statusDetails": {"message": "OSError: [WinError 1455] The paging file is too small for this operation to complete", "trace": "request = <SubRequest 'test_setup' for <Function test_google>>\n\n    @pytest.fixture(scope=\"class\")\n    def test_setup(request):\n        options = Options()\n        options.add_argument(\"start-maximized\")\n        options.add_experimental_option('excludeSwitches', ['enable-logging'])\n        global driver\n>       driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)\n\nconftest.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\chrome.py:32: in install\n    driver_path = self._get_driver_path(self.driver)\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\manager.py:19: in _get_driver_path\n    binary_path = self.driver_cache.find_driver(driver)\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\driver_cache.py:74: in find_driver\n    driver_version = driver.get_version()\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\driver.py:39: in get_version\n    self.get_latest_release_version()\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\driver.py:65: in get_latest_release_version\n    self.browser_version = get_browser_version_from_os(self.chrome_type)\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\utils.py:144: in get_browser_version_from_os\n    OSType.WIN: windows_browser_apps_to_cmd(\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\utils.py:125: in windows_browser_apps_to_cmd\n    powershell = determine_powershell()\nD:\\My projects\\python-pytest\\lib\\site-packages\\webdriver_manager\\utils.py:245: in determine_powershell\n    with subprocess.Popen(\nC:\\Users\\Sarang\\AppData\\Local\\Programs\\Python\\Python310\\lib\\subprocess.py:966: in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Popen: returncode: None args: '(dir 2>&1 *`|echo CMD);&<# rem #>echo powers...>\nargs = 'C:\\\\Windows\\\\system32\\\\cmd.exe /c \"(dir 2>&1 *`|echo CMD);&<# rem #>echo powershell\"'\nexecutable = None, preexec_fn = None, close_fds = False, pass_fds = ()\ncwd = None, env = None\nstartupinfo = <subprocess.STARTUPINFO object at 0x000002A0CDFF1A80>\ncreationflags = 0, shell = True, p2cread = Handle(9192), p2cwrite = -1\nc2pread = 12, c2pwrite = Handle(8960), errread = -1, errwrite = Handle(9204)\nunused_restore_signals = True, unused_gid = None, unused_gids = None\nunused_uid = None, unused_umask = -1, unused_start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       unused_restore_signals,\n                       unused_gid, unused_gids, unused_uid,\n                       unused_umask,\n                       unused_start_new_session):\n        \"\"\"Execute program (MS Windows version)\"\"\"\n    \n        assert not pass_fds, \"pass_fds not supported on Windows.\"\n    \n        if isinstance(args, str):\n            pass\n        elif isinstance(args, bytes):\n            if shell:\n                raise TypeError('bytes args is not allowed on Windows')\n            args = list2cmdline([args])\n        elif isinstance(args, os.PathLike):\n            if shell:\n                raise TypeError('path-like args is not allowed when '\n                                'shell is true')\n            args = list2cmdline([args])\n        else:\n            args = list2cmdline(args)\n    \n        if executable is not None:\n            executable = os.fsdecode(executable)\n    \n        # Process startup details\n        if startupinfo is None:\n            startupinfo = STARTUPINFO()\n        else:\n            # bpo-34044: Copy STARTUPINFO since it is modified above,\n            # so the caller can reuse it multiple times.\n            startupinfo = startupinfo.copy()\n    \n        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)\n        if use_std_handles:\n            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n            startupinfo.hStdInput = p2cread\n            startupinfo.hStdOutput = c2pwrite\n            startupinfo.hStdError = errwrite\n    \n        attribute_list = startupinfo.lpAttributeList\n        have_handle_list = bool(attribute_list and\n                                \"handle_list\" in attribute_list and\n                                attribute_list[\"handle_list\"])\n    \n        # If we were given an handle_list or need to create one\n        if have_handle_list or (use_std_handles and close_fds):\n            if attribute_list is None:\n                attribute_list = startupinfo.lpAttributeList = {}\n            handle_list = attribute_list[\"handle_list\"] = \\\n                list(attribute_list.get(\"handle_list\", []))\n    \n            if use_std_handles:\n                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]\n    \n            handle_list[:] = self._filter_handle_list(handle_list)\n    \n            if handle_list:\n                if not close_fds:\n                    warnings.warn(\"startupinfo.lpAttributeList['handle_list'] \"\n                                  \"overriding close_fds\", RuntimeWarning)\n    \n                # When using the handle_list we always request to inherit\n                # handles but the only handles that will be inherited are\n                # the ones in the handle_list\n                close_fds = False\n    \n        if shell:\n            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n            startupinfo.wShowWindow = _winapi.SW_HIDE\n            comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n            args = '{} /c \"{}\"'.format (comspec, args)\n    \n        if cwd is not None:\n            cwd = os.fsdecode(cwd)\n    \n        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)\n    \n        # Start the process\n        try:\n>           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n                                     # no special security\n                                     None, None,\n                                     int(not close_fds),\n                                     creationflags,\n                                     env,\n                                     cwd,\n                                     startupinfo)\nE                                    OSError: [WinError 1455] The paging file is too small for this operation to complete\n\nC:\\Users\\Sarang\\AppData\\Local\\Programs\\Python\\Python310\\lib\\subprocess.py:1435: OSError"}, "attachments": [{"name": "log", "source": "6692138e-dce2-4caf-be20-3ef9332ed4ac-attachment.txt", "type": "text/plain"}, {"name": "stderr", "source": "8f767325-d29a-4cbd-a830-47a75002d57f-attachment.txt", "type": "text/plain"}], "start": 1652508286740, "stop": 1652508286740, "uuid": "4498fcd5-cfe5-4ceb-ace1-1f241e7ec786", "historyId": "82ff1ed4bc71b24e7ccd7356e64ba564", "testCaseId": "fda9bc8c8f2b59df65a3d279c2163401", "fullName": "tests.google_test.TestGoogle#test_google", "labels": [{"name": "tag", "value": "@pytest.mark.usefixtures('test_setup')"}, {"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "google_test"}, {"name": "subSuite", "value": "TestGoogle"}, {"name": "host", "value": "DESKTOP-RD9F5N9"}, {"name": "thread", "value": "21356-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.google_test"}]}